The following is a digest of the repository "black_project".
This digest is designed to be easily parsed by Large Language Models.

--- SUMMARY ---
Repository: black_project
Files Analyzed: 22
Total Text Size: 48.37 KB
Estimated Tokens (text only): ~13,754

--- DIRECTORY STRUCTURE ---
black_project/
└── services/
    ├── order_service/
    │   ├── config/
    │   │   └── db.go
    │   ├── delivery/
    │   │   └── http/
    │   │       ├── handler/
    │   │       │   └── order_handler.go
    │   │       └── routes/
    │   │           └── order_routes.go
    │   ├── domain/
    │   │   ├── order_item.go
    │   │   └── order.go
    │   ├── messaging/
    │   │   └── user_registered_consumer.go
    │   ├── repository/
    │   │   ├── order_repository.go
    │   │   ├── postgres.go
    │   │   └── ser_view_postgres.go
    │   ├── usecase/
    │   │   └── order_usecase.go
    │   └── main.go
    └── user_service/
        ├── config/
        │   └── db.go
        ├── delivery/
        │   └── http/
        │       ├── handler/
        │       │   └── user_handler.go
        │       └── routes/
        │           └── user_routes.go
        ├── domain/
        │   └── user.go
        ├── messaging/
        │   └── rabbit_publisher.go
        ├── repository/
        │   ├── postgres.go
        │   └── user_repository.go
        ├── usecase/
        │   ├── event_publisher.go
        │   └── user_usecase.go
        ├── code.txt
        └── main.go


--- FILE CONTENTS ---
============================================================
FILE: services/order_service/config/db.go
============================================================
package config

import (
	"database/sql"
	"fmt"
	"os"

	_ "github.com/lib/pq"
)

func ConnectDB() (*sql.DB, error) {
	connStr := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
		os.Getenv("DB_HOST"),
		os.Getenv("DB_PORT"),
		os.Getenv("DB_USER"),
		os.Getenv("DB_PASSWORD"),
		os.Getenv("DB_NAME"),
		os.Getenv("DB_SSLMODE"),
	)

	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, err
	}

	// Verify connection
	if err := db.Ping(); err != nil {
		return nil, err
	}

	return db, nil
}



============================================================
FILE: services/order_service/delivery/http/handler/order_handler.go
============================================================
package handler

import (
	"encoding/json"
	"net/http"
	"order_service/domain"
	"order_service/usecase"
)

type OrderHandler struct {
	uc usecase.OrderUseCase
}

func NewOrderHandler(uc usecase.OrderUseCase) *OrderHandler {
	return &OrderHandler{uc: uc}
}

type CreateOrderRequest struct {
	UserID int64              `json:"user_id"`
	Items  []domain.OrderItem `json:"items"`
}

func (h *OrderHandler) Create(w http.ResponseWriter, r *http.Request) {
	var req CreateOrderRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid request", http.StatusBadRequest)
		return
	}

	order, err := h.uc.CreateOrder(req.UserID, req.Items)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(order)
}



============================================================
FILE: services/order_service/delivery/http/routes/order_routes.go
============================================================
package routes

import (
	"net/http"
	"order_service/delivery/http/handler"
)

func SetupOrderRoutes(h *handler.OrderHandler) *http.ServeMux {
	mux := http.NewServeMux()
	mux.HandleFunc("POST /orders", h.Create)
	return mux
}



============================================================
FILE: services/order_service/domain/order_item.go
============================================================
package domain

type OrderItem struct {
	ProductID int64   `json:"product_id"`
	Quantity  int     `json:"quantity"`
	Price     float64 `json:"price"`
}



============================================================
FILE: services/order_service/domain/order.go
============================================================
package domain

import "time"

type OrderStatus string

const (
	StatusPendingInventory OrderStatus = "PENDING_INVENTORY"
	StatusConfirmed        OrderStatus = "CONFIRMED"
	StatusCancelled        OrderStatus = "CANCELLED"
)

type Order struct {
	ID        int64        `json:"id"`
	UserID    int64        `json:"user_id"`
	Status    OrderStatus `json:"status"`
	Items     []OrderItem `json:"items"`
	CreatedAt time.Time   `json:"created_at"`
}



============================================================
FILE: services/order_service/messaging/user_registered_consumer.go
============================================================
package messaging

import (
	"encoding/json"
	"log"

	"github.com/streadway/amqp"
	"order_service/repository"
)

type UserRegisteredEvent struct {
	UserID int64 `json:"user_id"`
}

func ConsumeUserRegistered(
	ch *amqp.Channel,
	userViewRepo *repository.UserViewPostgres,
) error {

	q, err := ch.QueueDeclare(
		"user_registered_queue",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		return err
	}

	err = ch.QueueBind(
		q.Name,
		"user.registered",
		"events",
		false,
		nil,
	)
	if err != nil {
		return err
	}

	msgs, err := ch.Consume(
		q.Name,
		"",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		return err
	}

	go func() {
		for msg := range msgs {
			var event UserRegisteredEvent
			if err := json.Unmarshal(msg.Body, &event); err != nil {
				log.Println("invalid user.registered event:", err)
				continue
			}

			if err := userViewRepo.Insert(event.UserID); err != nil {
				log.Println("failed to insert into user_view:", err)
				continue
			}

			log.Println("user_view inserted for user_id:", event.UserID)
		}
	}()

	return nil
}



============================================================
FILE: services/order_service/repository/order_repository.go
============================================================
package repository

import "order_service/domain"

type OrderRepository interface {
	Create(order *domain.Order) error
	GetByID(id int64) (*domain.Order, error)
	UpdateStatus(id int64, status domain.OrderStatus) error
}



============================================================
FILE: services/order_service/repository/postgres.go
============================================================
package repository

import (
	"database/sql"
	"order_service/domain"
)

type postgresRepository struct {
	db *sql.DB
}

func NewPostgresRepository(db *sql.DB) OrderRepository {
	return &postgresRepository{db: db}
}

func (r *postgresRepository) Create(order *domain.Order) error {
	tx, err := r.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	err = tx.QueryRow(
		`INSERT INTO orders (user_id, status, created_at)
		 VALUES ($1, $2, $3)
		 RETURNING id`,
		order.UserID,
		order.Status,
		order.CreatedAt,
	).Scan(&order.ID)

	if err != nil {
		return err
	}

	
	for _, item := range order.Items {
		_, err := tx.Exec(
			`INSERT INTO order_items (order_id, product_id, quantity, price)
			 VALUES ($1, $2, $3, $4)`,
			order.ID,
			item.ProductID,
			item.Quantity,
			item.Price,
		)
		if err != nil {
			return err
		}
	}
	return tx.Commit()
}


func (r *postgresRepository) GetByID(id int64) (*domain.Order, error) {
	row := r.db.QueryRow(
		`SELECT id, user_id, status, created_at FROM orders WHERE id=$1`,
		id,
	)

	var o domain.Order
	err := row.Scan(&o.ID, &o.UserID, &o.Status, &o.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &o, nil
}

func (r *postgresRepository) UpdateStatus(id int64, status domain.OrderStatus) error {
	_, err := r.db.Exec(
		`UPDATE orders SET status=$1 WHERE id=$2`,
		status,
		id,
	)
	return err
}



============================================================
FILE: services/order_service/repository/ser_view_postgres.go
============================================================
package repository

import "database/sql"

type UserViewPostgres struct {
	db *sql.DB
}

func NewUserViewPostgres(db *sql.DB) *UserViewPostgres {
	return &UserViewPostgres{db: db}
}

func (r *UserViewPostgres) Insert(userID int64) error {
	_, err := r.db.Exec(
		`INSERT INTO user_view (user_id)
		 VALUES ($1)
		 ON CONFLICT (user_id) DO NOTHING`,
		userID,
	)
	return err
}



============================================================
FILE: services/order_service/usecase/order_usecase.go
============================================================
package usecase

import (
	"errors"
	"order_service/domain"
	"order_service/repository"
)

type OrderUseCase interface {
	CreateOrder(userID int64, items []domain.OrderItem) (*domain.Order, error)
}

type orderUseCase struct {
	orderRepo repository.OrderRepository
}

func NewOrderUseCase(orderRepo repository.OrderRepository) OrderUseCase {
	return &orderUseCase{orderRepo: orderRepo}
}

func (uc *orderUseCase) CreateOrder(
	userID int64,
	items []domain.OrderItem,
) (*domain.Order, error) {

	if userID <= 0 {
		return nil, errors.New("invalid user id")
	}
	if len(items) == 0 {
		return nil, errors.New("order must have items")
	}

	order := &domain.Order{
		UserID: userID,
		Items:  items,
	}

	err := uc.orderRepo.Create(order)
	if err != nil {
		return nil, err
	}

	return order, nil
}



============================================================
FILE: services/order_service/main.go
============================================================
package main

import (
	"log"
	"net/http"
	"os"
	"strings"

	"order_service/config"
	"order_service/delivery/http/handler"
	"order_service/delivery/http/routes"
	"order_service/messaging"
	"order_service/repository"
	"order_service/usecase"

	"github.com/streadway/amqp"
)

func main() {
	// -------------------------
	// Database
	// -------------------------
	db, err := config.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// -------------------------
	// RabbitMQ
	// -------------------------
	rabbitURL := os.Getenv("RABBITMQ_URL")
	if rabbitURL == "" {
		log.Fatal("RABBITMQ_URL is not set")
	}
	if !strings.HasPrefix(rabbitURL, "amqp://") && !strings.HasPrefix(rabbitURL, "amqps://") {
		log.Fatal("invalid RABBITMQ_URL: " + rabbitURL)
	}

	conn, err := amqp.Dial(rabbitURL)
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	ch, err := conn.Channel()
	if err != nil {
		log.Fatal(err)
	}
	defer ch.Close()

	err = ch.ExchangeDeclare(
		"events",
		"topic",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		log.Fatal(err)
	}

	// -------------------------
	// Rabbit Consumer
	// -------------------------
	userViewRepo := repository.NewUserViewPostgres(db)
	if err := messaging.ConsumeUserRegistered(ch, userViewRepo); err != nil {
		log.Fatal(err)
	}

	// -------------------------
	// Application
	// -------------------------
	orderRepo := repository.NewPostgresRepository(db)
	orderUC := usecase.NewOrderUseCase(orderRepo)
	orderHandler := handler.NewOrderHandler(orderUC)

	router := routes.SetupOrderRoutes(orderHandler)

	log.Println("Order Service running on :8081")
	log.Fatal(http.ListenAndServe(":8081", router))
}



============================================================
FILE: services/user_service/config/db.go
============================================================
package config

import (
    "database/sql"
    "fmt"
    "os"
    
    _ "github.com/lib/pq"
)

func ConnectDB() (*sql.DB, error) {
    connStr := fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
        os.Getenv("DB_HOST"),
        os.Getenv("DB_PORT"),
        os.Getenv("DB_USER"),
        os.Getenv("DB_PASSWORD"),
        os.Getenv("DB_NAME"),
        os.Getenv("DB_SSLMODE"),
    )
    
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }
    
    return db, nil
}


============================================================
FILE: services/user_service/delivery/http/handler/user_handler.go
============================================================
package handler

import (
	"user_service/domain"
	"user_service/usecase"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

type UserHandler struct {
	userUC usecase.UserUseCase
}

func NewUserHandler(userUC usecase.UserUseCase) *UserHandler {
	return &UserHandler{userUC: userUC}
}

type RegisterRequest struct {
	Email    string          `json:"email"`
	Password string          `json:"password"`
	FullName string          `json:"full_name"`
	Role     domain.Role     `json:"role"`
	Profile  domain.Profile  `json:"profile"`
}

type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type UserResponse struct {
	ID        int64           `json:"id"`
	FullName  string          `json:"full_name"`
	Email     string          `json:"email"`
	Role      domain.Role     `json:"role"`
	Profile   domain.Profile  `json:"profile"`
	CreatedAt string          `json:"created_at"`
}

type ErrorResponse struct {
	Error string `json:"error"`
}

type SuccessResponse struct {
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	user, err := h.userUC.Register(
		req.Email,
		req.Password,
		req.FullName,
		req.Role,
		req.Profile,
	)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	response := UserResponse{
		ID:        user.ID,
		FullName:  user.FullName,
		Email:     user.Email,
		Role:      user.Role,
		Profile:   user.Profile,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
	}

	respondWithJSON(w, http.StatusCreated, SuccessResponse{
		Message: "User registered successfully",
		Data:    response,
	})
}

func (h *UserHandler) Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	user, err := h.userUC.Login(req.Email, req.Password)
	if err != nil {
		respondWithError(w, http.StatusUnauthorized, err.Error())
		return
	}

	response := UserResponse{
		ID:        user.ID,
		FullName:  user.FullName,
		Email:     user.Email,
		Role:      user.Role,
		Profile:   user.Profile,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
	}

	respondWithJSON(w, http.StatusOK, SuccessResponse{
		Message: "Login successful",
		Data:    response,
	})
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Extract user ID from URL path or query parameter
	// Example: /users/{id}
	userID := r.URL.Query().Get("id")
	if userID == "" {
		respondWithError(w, http.StatusBadRequest, "User ID is required")
		return
	}

	var id int64
	if _, err := fmt.Sscanf(userID, "%d", &id); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid user ID")
		return
	}

	user, err := h.userUC.GetUserByID(id)
	if err != nil {
		respondWithError(w, http.StatusNotFound, err.Error())
		return
	}

	response := UserResponse{
		ID:        user.ID,
		FullName:  user.FullName,
		Email:     user.Email,
		Role:      user.Role,
		Profile:   user.Profile,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
	}

	respondWithJSON(w, http.StatusOK, SuccessResponse{
		Message: "User retrieved successfully",
		Data:    response,
	})
}

func (h *UserHandler) GetAllUsers(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Optional: Add authentication middleware here
	// Example: Only admins can get all users

	users, err := h.userUC.GetAllUsers()
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}

	var response []UserResponse
	for _, user := range users {
		response = append(response, UserResponse{
			ID:        user.ID,
			FullName:  user.FullName,
			Email:     user.Email,
			Role:      user.Role,
			Profile:   user.Profile,
			CreatedAt: user.CreatedAt.Format(time.RFC3339),
		})
	}

	respondWithJSON(w, http.StatusOK, SuccessResponse{
		Message: "Users retrieved successfully",
		Data:    response,
	})
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(payload)
}

func respondWithError(w http.ResponseWriter, code int, message string) {
	respondWithJSON(w, code, ErrorResponse{Error: message})
}


============================================================
FILE: services/user_service/delivery/http/routes/user_routes.go
============================================================
package routes

import (
	"user_service/delivery/http/handler"
	"encoding/json"
	"net/http"
)

func SetupUserRoutes(userHandler *handler.UserHandler) *http.ServeMux {
	mux := http.NewServeMux()

	// Use Go 1.22+ pattern matching
	mux.HandleFunc("POST /register", userHandler.Register)
	mux.HandleFunc("POST /login", userHandler.Login)
	mux.HandleFunc("GET /users/{id}", userHandler.GetUser)
	mux.HandleFunc("GET /users", userHandler.GetAllUsers)

	// Health check
	mux.HandleFunc("GET /health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
	})

	return mux
}


============================================================
FILE: services/user_service/domain/user.go
============================================================
package domain

import (
	"time"
)

type Role string

const (
	RoleAdmin  Role = "admin"
	RoleWorker Role = "worker"
	RoleClient Role = "client"
)

func (r Role) IsValid() bool {
	switch r {
	case RoleAdmin, RoleWorker, RoleClient:
		return true
	default:
		return false
	}
}

type Profile struct {
	FirstName string    `json:"first_name,omitempty"`
	LastName  string    `json:"last_name,omitempty"`
	BirthDate time.Time `json:"birth_date,omitempty"`
	Address   string    `json:"address,omitempty"`
}

type User struct {
	ID        int64     `json:"id"`
	FullName  string    `json:"full_name"`
	Email     string    `json:"email"`
	Password  string    `json:"password"`
	CreatedAt time.Time `json:"created_at"`

	Role    Role    `json:"role"`
	Profile Profile `json:"profile,omitempty"`
}


============================================================
FILE: services/user_service/messaging/rabbit_publisher.go
============================================================
package messaging

import "github.com/streadway/amqp"

type RabbitPublisher struct {
	ch *amqp.Channel
}

func NewRabbitPublisher(ch *amqp.Channel) *RabbitPublisher {
	return &RabbitPublisher{ch: ch}
}

func (p *RabbitPublisher) Publish(eventName string, body []byte) error {
	return p.ch.Publish(
		"events",   // exchange
		eventName, // routing key
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body: body,
		},
	)
}



============================================================
FILE: services/user_service/repository/postgres.go
============================================================
package repository

import (
	"user_service/domain"
	"database/sql"
	"fmt"
	"time"
)

type postgresRepository struct {
	db *sql.DB
}

func NewPostgresRepository(db *sql.DB) UserRepository {
	return &postgresRepository{db: db}
}

func (r *postgresRepository) GetByEmail(email string) (*domain.User, error) {
	query := `
		SELECT 
			u.id, u.full_name, u.email, u.password, u.created_at,
			p.first_name, p.last_name, p.birth_date, p.address,
			r.role
		FROM users u
		LEFT JOIN profiles p ON u.id = p.user_id
		LEFT JOIN roles r ON u.id = r.user_id
		WHERE u.email = $1
		LIMIT 1
	`

	user, err := r.scanUser(query, email)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with email %s not found", email)
		}
		return nil, err
	}

	return user, nil
}

func (r *postgresRepository) GetByID(id int64) (*domain.User, error) {
	query := `
		SELECT 
			u.id, u.full_name, u.email, u.password, u.created_at,
			p.first_name, p.last_name, p.birth_date, p.address,
			r.role
		FROM users u
		LEFT JOIN profiles p ON u.id = p.user_id
		LEFT JOIN roles r ON u.id = r.user_id
		WHERE u.id = $1
		LIMIT 1
	`

	user, err := r.scanUser(query, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with ID %d not found", id)
		}
		return nil, err
	}

	return user, nil
}

func (r *postgresRepository) Create(user *domain.User) error {
	tx, err := r.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if user.CreatedAt.IsZero() {
		user.CreatedAt = time.Now()
	}

	userQuery := `
		INSERT INTO users (full_name, email, password, created_at)
		VALUES ($1, $2, $3, $4)
		RETURNING id
	`

	err = tx.QueryRow(
		userQuery,
		user.FullName,
		user.Email,
		user.Password,
		user.CreatedAt,
	).Scan(&user.ID)

	if err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}

	profileQuery := `
		INSERT INTO profiles (user_id, first_name, last_name, birth_date, address)
		VALUES ($1, $2, $3, $4, $5)
		ON CONFLICT (user_id) DO UPDATE SET
			first_name = EXCLUDED.first_name,
			last_name = EXCLUDED.last_name,
			birth_date = EXCLUDED.birth_date,
			address = EXCLUDED.address
		`

	_, err = tx.Exec(
		profileQuery,
		user.ID,
		user.Profile.FirstName,
		user.Profile.LastName,
		user.Profile.BirthDate,
		user.Profile.Address,
	)

	if err != nil {
		return fmt.Errorf("failed to create profile: %w", err)
	}

	roleQuery := `
		INSERT INTO roles (user_id, role)
		VALUES ($1, $2)
		ON CONFLICT (user_id, role) DO NOTHING
	`

	_, err = tx.Exec(roleQuery, user.ID, string(user.Role))
	if err != nil {
		return fmt.Errorf("failed to assign role: %w", err)
	}

	return tx.Commit()
}

func (r *postgresRepository) GetAll() ([]*domain.User, error) {
	query := `
		SELECT 
			u.id, u.full_name, u.email, u.password, u.created_at,
			p.first_name, p.last_name, p.birth_date, p.address,
			r.role
		FROM users u
		LEFT JOIN profiles p ON u.id = p.user_id
		LEFT JOIN roles r ON u.id = r.user_id
		ORDER BY u.created_at DESC
	`

	rows, err := r.db.Query(query)
	if err != nil {
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var users []*domain.User
	for rows.Next() {
		user, err := r.scanUserFromRows(rows)
		if err != nil {
			return nil, err
		}
		users = append(users, user)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %w", err)
	}

	return users, nil
}

func (r *postgresRepository) GetUserWithProfile(userID int64) (*domain.User, error) {
	return r.GetByID(userID)
}

func (r *postgresRepository) EmailExists(email string) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)`
	var exists bool
	
	err := r.db.QueryRow(query, email).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("failed to check email existence: %w", err)
	}
	
	return exists, nil
}

func (r *postgresRepository) scanUser(query string, args ...interface{}) (*domain.User, error) {
	var user domain.User
	var firstName, lastName, address sql.NullString
	var birthDate sql.NullTime
	var role sql.NullString

	err := r.db.QueryRow(query, args...).Scan(
		&user.ID,
		&user.FullName,
		&user.Email,
		&user.Password,
		&user.CreatedAt,
		&firstName,
		&lastName,
		&birthDate,
		&address,
		&role,
	)

	if err != nil {
		return nil, err
	}

	user.Profile = domain.Profile{
		FirstName: firstName.String,
		LastName:  lastName.String,
		Address:   address.String,
	}

	if birthDate.Valid {
		user.Profile.BirthDate = birthDate.Time
	}

	if role.Valid {
		user.Role = domain.Role(role.String)
	}

	return &user, nil
}

func (r *postgresRepository) scanUserFromRows(rows *sql.Rows) (*domain.User, error) {
	var user domain.User
	var firstName, lastName, address sql.NullString
	var birthDate sql.NullTime
	var role sql.NullString

	err := rows.Scan(
		&user.ID,
		&user.FullName,
		&user.Email,
		&user.Password,
		&user.CreatedAt,
		&firstName,
		&lastName,
		&birthDate,
		&address,
		&role,
	)

	if err != nil {
		return nil, err
	}

	user.Profile = domain.Profile{
		FirstName: firstName.String,
		LastName:  lastName.String,
		Address:   address.String,
	}

	if birthDate.Valid {
		user.Profile.BirthDate = birthDate.Time
	}

	if role.Valid {
		user.Role = domain.Role(role.String)
	}

	return &user, nil
}


============================================================
FILE: services/user_service/repository/user_repository.go
============================================================
package repository

import "user_service/domain"

type UserRepository interface {
	GetByEmail(email string) (*domain.User, error)
	GetByID(id int64) (*domain.User, error)
	Create(user *domain.User) error
	GetAll() ([]*domain.User, error)
	GetUserWithProfile(userID int64) (*domain.User, error)
	EmailExists(email string) (bool, error)
}


============================================================
FILE: services/user_service/usecase/event_publisher.go
============================================================
package usecase

type EventPublisher interface {
	Publish(eventName string, payload []byte) error
}



============================================================
FILE: services/user_service/usecase/user_usecase.go
============================================================
package usecase

import (
	"user_service/domain"
	"user_service/repository"
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"
	"time"

	"golang.org/x/crypto/argon2"
	"encoding/json"

)

type UserUseCase interface {
	Register(email, password, fullName string, role domain.Role, profile domain.Profile) (*domain.User, error)
	Login(email, password string) (*domain.User, error)
	GetUserByID(id int64) (*domain.User, error)
	GetAllUsers() ([]*domain.User, error)
	ValidateUserCredentials(email, password string) (*domain.User, error)
}

type userUseCase struct {
	userRepo repository.UserRepository
	publisher EventPublisher
}

func NewUserUseCase(
	userRepo repository.UserRepository,
	publisher EventPublisher,
) UserUseCase {
	return &userUseCase{
		userRepo: userRepo,
		publisher: publisher,
	}
}

type argon2Params struct {
	memory      uint32
	iterations  uint32
	parallelism uint8
	saltLength  uint32
	keyLength   uint32
}

var argon2Config = &argon2Params{
	memory:      64 * 1024, // 64 MB
	iterations:  3,
	parallelism: 2,
	saltLength:  16,
	keyLength:   32,
}

func (uc *userUseCase) Register(email, password, fullName string, role domain.Role, profile domain.Profile) (*domain.User, error) {
	// 1. Validate inputs
	if strings.TrimSpace(email) == "" {
		return nil, errors.New("email is required")
	}
	if strings.TrimSpace(password) == "" {
		return nil, errors.New("password is required")
	}
	if strings.TrimSpace(fullName) == "" {
		return nil, errors.New("full name is required")
	}
	if !role.IsValid() {
		return nil, errors.New("invalid role")
	}
	if len(password) < 8 {
		return nil, errors.New("password must be at least 8 characters")
	}

	// 2. Check if email already exists
	exists, err := uc.userRepo.EmailExists(email)
	if err != nil {
		return nil, fmt.Errorf("failed to check email: %w", err)
	}
	if exists {
		return nil, errors.New("email already registered")
	}

	// 3. Hash password with Argon2
	hashedPassword, err := uc.hashPassword(password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// 4. Create user domain object
	user := &domain.User{
		FullName:  strings.TrimSpace(fullName),
		Email:     strings.ToLower(strings.TrimSpace(email)),
		Password:  hashedPassword,
		Role:      role,
		Profile:   profile,
		CreatedAt: time.Now(),
	}

	// 5. Save to repository
	err = uc.userRepo.Create(user)
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}


	if uc.publisher != nil {
	event := map[string]interface{}{
		"user_id": user.ID,
	}

	data, _ := json.Marshal(event)
	_ = uc.publisher.Publish("user.registered", data)
}


	// 6. Clear sensitive data before returning
	user.Password = ""
	return user, nil
}

func (uc *userUseCase) Login(email, password string) (*domain.User, error) {
	// 1. Validate inputs
	if strings.TrimSpace(email) == "" || strings.TrimSpace(password) == "" {
		return nil, errors.New("email and password are required")
	}

	// 2. Get user from repository
	user, err := uc.userRepo.GetByEmail(strings.ToLower(strings.TrimSpace(email)))
	if err != nil {
		// Security: Return generic error to avoid user enumeration
		return nil, errors.New("invalid credentials")
	}

	// 3. Verify password with Argon2
	valid, err := uc.verifyPassword(password, user.Password)
	if err != nil {
		return nil, fmt.Errorf("password verification failed: %w", err)
	}
	if !valid {
		return nil, errors.New("invalid credentials")
	}

	// 5. Clear sensitive data before returning
	user.Password = ""
	return user, nil
}

func (uc *userUseCase) ValidateUserCredentials(email, password string) (*domain.User, error) {
	return uc.Login(email, password)
}

func (uc *userUseCase) GetUserByID(id int64) (*domain.User, error) {
	if id <= 0 {
		return nil, errors.New("invalid user ID")
	}

	user, err := uc.userRepo.GetByID(id)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Clear sensitive data
	user.Password = ""
	return user, nil
}

func (uc *userUseCase) GetAllUsers() ([]*domain.User, error) {
	users, err := uc.userRepo.GetAll()
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	// Clear sensitive data from all users
	for _, user := range users {
		user.Password = ""
	}

	return users, nil
}

func (uc *userUseCase) hashPassword(password string) (string, error) {
	// Generate random salt
	salt := make([]byte, argon2Config.saltLength)
	_, err := rand.Read(salt)
	if err != nil {
		return "", err
	}

	// Hash password with Argon2
	hash := argon2.IDKey(
		[]byte(password),
		salt,
		argon2Config.iterations,
		argon2Config.memory,
		argon2Config.parallelism,
		argon2Config.keyLength,
	)

	// Encode salt and hash to base64
	b64Salt := base64.RawStdEncoding.EncodeToString(salt)
	b64Hash := base64.RawStdEncoding.EncodeToString(hash)

	// Format: $argon2id$v=19$m=65536,t=3,p=2$salt$hash
	encodedHash := fmt.Sprintf("$argon2id$v=19$m=%d,t=%d,p=%d$%s$%s",
		argon2Config.memory,
		argon2Config.iterations,
		argon2Config.parallelism,
		b64Salt,
		b64Hash,
	)

	return encodedHash, nil
}

func (uc *userUseCase) verifyPassword(password, encodedHash string) (bool, error) {
	// Parse encoded hash
	parts := strings.Split(encodedHash, "$")
	if len(parts) != 6 {
		return false, errors.New("invalid hash format")
	}

	// Extract parameters
	var memory, iterations uint32
	var parallelism uint8
	_, err := fmt.Sscanf(parts[3], "m=%d,t=%d,p=%d", &memory, &iterations, &parallelism)
	if err != nil {
		return false, err
	}

	// Decode salt and hash
	salt, err := base64.RawStdEncoding.DecodeString(parts[4])
	if err != nil {
		return false, err
	}

	expectedHash, err := base64.RawStdEncoding.DecodeString(parts[5])
	if err != nil {
		return false, err
	}

	// Compute hash with provided password
	actualHash := argon2.IDKey(
		[]byte(password),
		salt,
		iterations,
		memory,
		parallelism,
		uint32(len(expectedHash)),
	)

	// Constant time comparison to prevent timing attacks
	return subtle.ConstantTimeCompare(actualHash, expectedHash) == 1, nil
}


============================================================
FILE: services/user_service/code.txt
============================================================
The following is a digest of the repository "black_project".
This digest is designed to be easily parsed by Large Language Models.

--- SUMMARY ---
Repository: black_project
Files Analyzed: 8
Total Text Size: 18.75 KB
Estimated Tokens (text only): ~5,357

--- DIRECTORY STRUCTURE ---
black_project/
├── config/
│   └── db.go
├── delivery/
│   └── http/
│       ├── user_handler.go
│       └── user_routes.go
├── domain/
│   └── user.go
├── repository/
│   ├── postgres.go
│   └── user_repository.go
├── usecase/
│   └── user_usecase.go
└── main.go


--- FILE CONTENTS ---
============================================================
FILE: config/db.go
============================================================
package config

import (
    "database/sql"
    "fmt"
    "os"
    
    _ "github.com/lib/pq"
)

func ConnectDB() (*sql.DB, error) {
    connStr := fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
        os.Getenv("DB_HOST"),
        os.Getenv("DB_PORT"),
        os.Getenv("DB_USER"),
        os.Getenv("DB_PASSWORD"),
        os.Getenv("DB_NAME"),
        os.Getenv("DB_SSLMODE"),
    )
    
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }
    
    return db, nil
}


============================================================
FILE: delivery/http/user_handler.go
============================================================
package handler

import (
	"black_project/domain"
	"black_project/usecase"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"
)

type UserHandler struct {
	userUC usecase.UserUseCase
}

func NewUserHandler(userUC usecase.UserUseCase) *UserHandler {
	return &UserHandler{userUC: userUC}
}

type RegisterRequest struct {
	Email    string          `json:"email"`
	Password string          `json:"password"`
	FullName string          `json:"full_name"`
	Role     domain.Role     `json:"role"`
	Profile  domain.Profile  `json:"profile"`
}

type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type UserResponse struct {
	ID        int64           `json:"id"`
	FullName  string          `json:"full_name"`
	Email     string          `json:"email"`
	Role      domain.Role     `json:"role"`
	Profile   domain.Profile  `json:"profile"`
	CreatedAt string          `json:"created_at"`
}

type ErrorResponse struct {
	Error string `json:"error"`
}

type SuccessResponse struct {
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	user, err := h.userUC.Register(
		req.Email,
		req.Password,
		req.FullName,
		req.Role,
		req.Profile,
	)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	response := UserResponse{
		ID:        user.ID,
		FullName:  user.FullName,
		Email:     user.Email,
		Role:      user.Role,
		Profile:   user.Profile,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
	}

	respondWithJSON(w, http.StatusCreated, SuccessResponse{
		Message: "User registered successfully",
		Data:    response,
	})
}

func (h *UserHandler) Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	user, err := h.userUC.Login(req.Email, req.Password)
	if err != nil {
		respondWithError(w, http.StatusUnauthorized, err.Error())
		return
	}

	response := UserResponse{
		ID:        user.ID,
		FullName:  user.FullName,
		Email:     user.Email,
		Role:      user.Role,
		Profile:   user.Profile,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
	}

	respondWithJSON(w, http.StatusOK, SuccessResponse{
		Message: "Login successful",
		Data:    response,
	})
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Extract user ID from URL path or query parameter
	// Example: /users/{id}
	userID := r.URL.Query().Get("id")
	if userID == "" {
		respondWithError(w, http.StatusBadRequest, "User ID is required")
		return
	}

	var id int64
	if _, err := fmt.Sscanf(userID, "%d", &id); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid user ID")
		return
	}

	user, err := h.userUC.GetUserByID(id)
	if err != nil {
		respondWithError(w, http.StatusNotFound, err.Error())
		return
	}

	response := UserResponse{
		ID:        user.ID,
		FullName:  user.FullName,
		Email:     user.Email,
		Role:      user.Role,
		Profile:   user.Profile,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
	}

	respondWithJSON(w, http.StatusOK, SuccessResponse{
		Message: "User retrieved successfully",
		Data:    response,
	})
}

func (h *UserHandler) GetAllUsers(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Optional: Add authentication middleware here
	// Example: Only admins can get all users

	users, err := h.userUC.GetAllUsers()
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}

	var response []UserResponse
	for _, user := range users {
		response = append(response, UserResponse{
			ID:        user.ID,
			FullName:  user.FullName,
			Email:     user.Email,
			Role:      user.Role,
			Profile:   user.Profile,
			CreatedAt: user.CreatedAt.Format(time.RFC3339),
		})
	}

	respondWithJSON(w, http.StatusOK, SuccessResponse{
		Message: "Users retrieved successfully",
		Data:    response,
	})
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(payload)
}

func respondWithError(w http.ResponseWriter, code int, message string) {
	respondWithJSON(w, code, ErrorResponse{Error: message})
}


============================================================
FILE: delivery/http/user_routes.go
============================================================
package routes

import (
	"black_project/delivery/http/handler"
	"encoding/json"
	"net/http"
)

func SetupUserRoutes(userHandler *handler.UserHandler) *http.ServeMux {
	mux := http.NewServeMux()

	// Use Go 1.22+ pattern matching
	mux.HandleFunc("POST /register", userHandler.Register)
	mux.HandleFunc("POST /login", userHandler.Login)
	mux.HandleFunc("GET /users", userHandler.GetAllUsers)

	// Health check
	mux.HandleFunc("GET /health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
	})

	return mux
}}


============================================================
FILE: domain/user.go
============================================================
package domain

import (
	"time"
)

type Role string

const (
	RoleAdmin  Role = "admin"
	RoleWorker Role = "worker"
	RoleClient Role = "client"
)

func (r Role) IsValid() bool {
	switch r {
	case RoleAdmin, RoleWorker, RoleClient:
		return true
	default:
		return false
	}
}

type Profile struct {
	FirstName string    `json:"first_name,omitempty"`
	LastName  string    `json:"last_name,omitempty"`
	BirthDate time.Time `json:"birth_date,omitempty"`
	Address   string    `json:"address,omitempty"`
}

type User struct {
	ID        int64     `json:"id"`
	FullName  string    `json:"full_name"`
	Email     string    `json:"email"`
	Password  string    `json:"password"`
	CreatedAt time.Time `json:"created_at"`

	Role    Role    `json:"role"`
	Profile Profile `json:"profile,omitempty"`
}


============================================================
FILE: repository/postgres.go
============================================================
package repository

import (
	"black_project/domain"
	"database/sql"
	"fmt"
	"time"
)

type postgresRepository struct {
	db *sql.DB
}

func NewPostgresRepository(db *sql.DB) UserRepository {
	return &postgresRepository{db: db}
}

func (r *postgresRepository) GetByEmail(email string) (*domain.User, error) {
	query := `
		SELECT 
			u.id, u.full_name, u.email, u.password, u.created_at,
			p.first_name, p.last_name, p.birth_date, p.address,
			r.role
		FROM users u
		LEFT JOIN profiles p ON u.id = p.user_id
		LEFT JOIN roles r ON u.id = r.user_id
		WHERE u.email = $1
		LIMIT 1
	`

	user, err := r.scanUser(query, email)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with email %s not found", email)
		}
		return nil, err
	}

	return user, nil
}

func (r *postgresRepository) GetByID(id int64) (*domain.User, error) {
	query := `
		SELECT 
			u.id, u.full_name, u.email, u.password, u.created_at,
			p.first_name, p.last_name, p.birth_date, p.address,
			r.role
		FROM users u
		LEFT JOIN profiles p ON u.id = p.user_id
		LEFT JOIN roles r ON u.id = r.user_id
		WHERE u.id = $1
		LIMIT 1
	`

	user, err := r.scanUser(query, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with ID %d not found", id)
		}
		return nil, err
	}

	return user, nil
}

func (r *postgresRepository) Create(user *domain.User) error {
	tx, err := r.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if user.CreatedAt.IsZero() {
		user.CreatedAt = time.Now()
	}

	userQuery := `
		INSERT INTO users (full_name, email, password, created_at)
		VALUES ($1, $2, $3, $4)
		RETURNING id
	`

	err = tx.QueryRow(
		userQuery,
		user.FullName,
		user.Email,
		user.Password,
		user.CreatedAt,
	).Scan(&user.ID)

	if err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}

	profileQuery := `
		INSERT INTO profiles (user_id, first_name, last_name, birth_date, address)
		VALUES ($1, $2, $3, $4, $5)
		ON CONFLICT (user_id) DO UPDATE SET
			first_name = EXCLUDED.first_name,
			last_name = EXCLUDED.last_name,
			birth_date = EXCLUDED.birth_date,
			address = EXCLUDED.address,
			updated_at = CURRENT_TIMESTAMP
	`

	_, err = tx.Exec(
		profileQuery,
		user.ID,
		user.Profile.FirstName,
		user.Profile.LastName,
		user.Profile.BirthDate,
		user.Profile.Address,
	)

	if err != nil {
		return fmt.Errorf("failed to create profile: %w", err)
	}

	roleQuery := `
		INSERT INTO roles (user_id, role)
		VALUES ($1, $2)
		ON CONFLICT (user_id, role) DO NOTHING
	`

	_, err = tx.Exec(roleQuery, user.ID, string(user.Role))
	if err != nil {
		return fmt.Errorf("failed to assign role: %w", err)
	}

	return tx.Commit()
}

func (r *postgresRepository) GetAll() ([]*domain.User, error) {
	query := `
		SELECT 
			u.id, u.full_name, u.email, u.password, u.created_at,
			p.first_name, p.last_name, p.birth_date, p.address,
			r.role
		FROM users u
		LEFT JOIN profiles p ON u.id = p.user_id
		LEFT JOIN roles r ON u.id = r.user_id
		ORDER BY u.created_at DESC
	`

	rows, err := r.db.Query(query)
	if err != nil {
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var users []*domain.User
	for rows.Next() {
		user, err := r.scanUserFromRows(rows)
		if err != nil {
			return nil, err
		}
		users = append(users, user)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %w", err)
	}

	return users, nil
}

func (r *postgresRepository) GetUserWithProfile(userID int64) (*domain.User, error) {
	return r.GetByID(userID)
}

func (r *postgresRepository) EmailExists(email string) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)`
	var exists bool
	
	err := r.db.QueryRow(query, email).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("failed to check email existence: %w", err)
	}
	
	return exists, nil
}

func (r *postgresRepository) scanUser(query string, args ...interface{}) (*domain.User, error) {
	var user domain.User
	var firstName, lastName, address sql.NullString
	var birthDate sql.NullTime
	var role sql.NullString

	err := r.db.QueryRow(query, args...).Scan(
		&user.ID,
		&user.FullName,
		&user.Email,
		&user.Password,
		&user.CreatedAt,
		&firstName,
		&lastName,
		&birthDate,
		&address,
		&role,
	)

	if err != nil {
		return nil, err
	}

	user.Profile = domain.Profile{
		FirstName: firstName.String,
		LastName:  lastName.String,
		Address:   address.String,
	}

	if birthDate.Valid {
		user.Profile.BirthDate = birthDate.Time
	}

	if role.Valid {
		user.Role = domain.Role(role.String)
	}

	return &user, nil
}

func (r *postgresRepository) scanUserFromRows(rows *sql.Rows) (*domain.User, error) {
	var user domain.User
	var firstName, lastName, address sql.NullString
	var birthDate sql.NullTime
	var role sql.NullString

	err := rows.Scan(
		&user.ID,
		&user.FullName,
		&user.Email,
		&user.Password,
		&user.CreatedAt,
		&firstName,
		&lastName,
		&birthDate,
		&address,
		&role,
	)

	if err != nil {
		return nil, err
	}

	user.Profile = domain.Profile{
		FirstName: firstName.String,
		LastName:  lastName.String,
		Address:   address.String,
	}

	if birthDate.Valid {
		user.Profile.BirthDate = birthDate.Time
	}

	if role.Valid {
		user.Role = domain.Role(role.String)
	}

	return &user, nil
}


============================================================
FILE: repository/user_repository.go
============================================================
package repository

import "black_project/domain"

type UserRepository interface {
	GetByEmail(email string) (*domain.User, error)
	GetByID(id int64) (*domain.User, error)
	Create(user *domain.User) error
	GetAll() ([]*domain.User, error)
	GetUserWithProfile(userID int64) (*domain.User, error)
	EmailExists(email string) (bool, error)
}


============================================================
FILE: usecase/user_usecase.go
============================================================
package usecase

import (
	"black_project/domain"
	"black_project/repository"
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"
	"time"

	"golang.org/x/crypto/argon2"
)

type UserUseCase interface {
	Register(email, password, fullName string, role domain.Role, profile domain.Profile) (*domain.User, error)
	Login(email, password string) (*domain.User, error)
	GetUserByID(id int64) (*domain.User, error)
	GetAllUsers() ([]*domain.User, error)
	ValidateUserCredentials(email, password string) (*domain.User, error)
}

type userUseCase struct {
	userRepo repository.UserRepository
}

func NewUserUseCase(userRepo repository.UserRepository) UserUseCase {
	return &userUseCase{
		userRepo: userRepo,
	}
}

type argon2Params struct {
	memory      uint32
	iterations  uint32
	parallelism uint8
	saltLength  uint32
	keyLength   uint32
}

var argon2Config = &argon2Params{
	memory:      64 * 1024, // 64 MB
	iterations:  3,
	parallelism: 2,
	saltLength:  16,
	keyLength:   32,
}

func (uc *userUseCase) Register(email, password, fullName string, role domain.Role, profile domain.Profile) (*domain.User, error) {
	// 1. Validate inputs
	if strings.TrimSpace(email) == "" {
		return nil, errors.New("email is required")
	}
	if strings.TrimSpace(password) == "" {
		return nil, errors.New("password is required")
	}
	if strings.TrimSpace(fullName) == "" {
		return nil, errors.New("full name is required")
	}
	if !role.IsValid() {
		return nil, errors.New("invalid role")
	}
	if len(password) < 8 {
		return nil, errors.New("password must be at least 8 characters")
	}

	// 2. Check if email already exists
	exists, err := uc.userRepo.EmailExists(email)
	if err != nil {
		return nil, fmt.Errorf("failed to check email: %w", err)
	}
	if exists {
		return nil, errors.New("email already registered")
	}

	// 3. Hash password with Argon2
	hashedPassword, err := uc.hashPassword(password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// 4. Create user domain object
	user := &domain.User{
		FullName:  strings.TrimSpace(fullName),
		Email:     strings.ToLower(strings.TrimSpace(email)),
		Password:  hashedPassword,
		Role:      role,
		Profile:   profile,
		CreatedAt: time.Now(),
	}

	// 5. Save to repository
	err = uc.userRepo.Create(user)
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// 6. Clear sensitive data before returning
	user.Password = ""
	return user, nil
}

func (uc *userUseCase) Login(email, password string) (*domain.User, error) {
	// 1. Validate inputs
	if strings.TrimSpace(email) == "" || strings.TrimSpace(password) == "" {
		return nil, errors.New("email and password are required")
	}

	// 2. Get user from repository
	user, err := uc.userRepo.GetByEmail(strings.ToLower(strings.TrimSpace(email)))
	if err != nil {
		// Security: Return generic error to avoid user enumeration
		return nil, errors.New("invalid credentials")
	}

	// 3. Verify password with Argon2
	valid, err := uc.verifyPassword(password, user.Password)
	if err != nil {
		return nil, fmt.Errorf("password verification failed: %w", err)
	}
	if !valid {
		return nil, errors.New("invalid credentials")
	}

	// 5. Clear sensitive data before returning
	user.Password = ""
	return user, nil
}

func (uc *userUseCase) ValidateUserCredentials(email, password string) (*domain.User, error) {
	return uc.Login(email, password)
}

func (uc *userUseCase) GetUserByID(id int64) (*domain.User, error) {
	if id <= 0 {
		return nil, errors.New("invalid user ID")
	}

	user, err := uc.userRepo.GetByID(id)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Clear sensitive data
	user.Password = ""
	return user, nil
}

func (uc *userUseCase) GetAllUsers() ([]*domain.User, error) {
	users, err := uc.userRepo.GetAll()
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	// Clear sensitive data from all users
	for _, user := range users {
		user.Password = ""
	}

	return users, nil
}

func (uc *userUseCase) hashPassword(password string) (string, error) {
	// Generate random salt
	salt := make([]byte, argon2Config.saltLength)
	_, err := rand.Read(salt)
	if err != nil {
		return "", err
	}

	// Hash password with Argon2
	hash := argon2.IDKey(
		[]byte(password),
		salt,
		argon2Config.iterations,
		argon2Config.memory,
		argon2Config.parallelism,
		argon2Config.keyLength,
	)

	// Encode salt and hash to base64
	b64Salt := base64.RawStdEncoding.EncodeToString(salt)
	b64Hash := base64.RawStdEncoding.EncodeToString(hash)

	// Format: $argon2id$v=19$m=65536,t=3,p=2$salt$hash
	encodedHash := fmt.Sprintf("$argon2id$v=19$m=%d,t=%d,p=%d$%s$%s",
		argon2Config.memory,
		argon2Config.iterations,
		argon2Config.parallelism,
		b64Salt,
		b64Hash,
	)

	return encodedHash, nil
}

func (uc *userUseCase) verifyPassword(password, encodedHash string) (bool, error) {
	// Parse encoded hash
	parts := strings.Split(encodedHash, "$")
	if len(parts) != 6 {
		return false, errors.New("invalid hash format")
	}

	// Extract parameters
	var memory, iterations uint32
	var parallelism uint8
	_, err := fmt.Sscanf(parts[3], "m=%d,t=%d,p=%d", &memory, &iterations, &parallelism)
	if err != nil {
		return false, err
	}

	// Decode salt and hash
	salt, err := base64.RawStdEncoding.DecodeString(parts[4])
	if err != nil {
		return false, err
	}

	expectedHash, err := base64.RawStdEncoding.DecodeString(parts[5])
	if err != nil {
		return false, err
	}

	// Compute hash with provided password
	actualHash := argon2.IDKey(
		[]byte(password),
		salt,
		iterations,
		memory,
		parallelism,
		uint32(len(expectedHash)),
	)

	// Constant time comparison to prevent timing attacks
	return subtle.ConstantTimeCompare(actualHash, expectedHash) == 1, nil
}


============================================================
FILE: main.go
============================================================
package main

import (
    "black_project/config"
    "black_project/delivery/http/handler"
    "black_project/delivery/http/routes"
    "black_project/repository"
    "black_project/usecase"
    "log"
    "net/http"
)

func main() {
    // Database connection
    db, err := config.ConnectDB()
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    defer db.Close()

    // Initialize Clean Architecture layers
    userRepo := repository.NewPostgresRepository(db)
    userUC := usecase.NewUserUseCase(userRepo)
    userHandler := handler.NewUserHandler(userUC)
    
    // Setup routes
    router := routes.SetupUserRoutes(userHandler)

    // Start server
    port := "8080"
    log.Printf("Server starting on :%s", port)
    log.Fatal(http.ListenAndServe(":"+port, router))
}

============================================================
FILE: services/user_service/main.go
============================================================
package main

import (
	"log"
	"net/http"
	"os"
	"strings"

	"user_service/config"
	"user_service/delivery/http/handler"
	"user_service/delivery/http/routes"
	"user_service/messaging"
	"user_service/repository"
	"user_service/usecase"

	"github.com/streadway/amqp"
)

func main() {
	// -------------------------
	// Database
	// -------------------------
	db, err := config.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// -------------------------
	// RabbitMQ
	// -------------------------
	rabbitURL := os.Getenv("RABBITMQ_URL")
	if rabbitURL == "" {
		log.Fatal("RABBITMQ_URL is not set")
	}
	if !strings.HasPrefix(rabbitURL, "amqp://") && !strings.HasPrefix(rabbitURL, "amqps://") {
		log.Fatal("invalid RABBITMQ_URL: " + rabbitURL)
	}

	conn, err := amqp.Dial(rabbitURL)
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	ch, err := conn.Channel()
	if err != nil {
		log.Fatal(err)
	}
	defer ch.Close()

	err = ch.ExchangeDeclare(
		"events",
		"topic",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		log.Fatal(err)
	}

	publisher := messaging.NewRabbitPublisher(ch)

	// -------------------------
	// Application
	// -------------------------
	userRepo := repository.NewPostgresRepository(db)
	userUC := usecase.NewUserUseCase(userRepo, publisher)
	userHandler := handler.NewUserHandler(userUC)

	router := routes.SetupUserRoutes(userHandler)

	log.Println("User Service running on :8080")
	log.Fatal(http.ListenAndServe(":8080", router))
}